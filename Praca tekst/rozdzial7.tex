\chapter{Metodyka eksperymentów}
\label{cha:metodyka}

Możliwość ustawienia wielu różnych wartości parametrów zaimplementowanego w napisanej aplikacji algorytmu pozwala na przeprowadzenie serii eksperymentów badających ich wpływ na otrzymywane rezultaty. Również wprowadzenie wielu modyfikacji do samego algorytmu powoduje, że należy sprawdzić, czy te zmiany powodują istotne różnice w kwestii rozwiązywania problemu. Być może wprowadzone zmiany powodują, że algorytm znajduje rozwiązania niezgodne z oczekiwaniami, jego zbieżność uległa pogorszeniu. Z wymienionych przyczyn została przeprowadzona znaczna liczba testów z wykorzystaniem ogólnodostępnych instancji testowych weryfikujących poprawność ogólnego działania algorytmu oraz badających wpływ poszczególnych parametrów algorytmu na jego działanie.
 
\section{Instancje testowe}
\label{sec:instancje}
Popularność problemu QAP powoduje, że istnieje cała gama instancji testowych problemu z podanym optymalnym rozwiązaniem, lub najlepszym znalezionym rozwiązaniem dotychczas. Wykorzystane w eksperymentach instancje testowe pochodzą ze strony \cite{INSTANCJE} i są w postaci plików \textit{*.dat} zawierających rozmiar problemu i odpowiednio macierze odległości i przepływu. W przypadku, gdy jest inaczej, instancja opatrzona jest stosownym komentarzem. Podawane w instancji rozwiązania są permutacjami, których elementy reprezentują przydzielone obiekty, a ich pozycja reprezentuje lokalizacje, do której zostały przydzielone.

Do testów wybrano jedenaście instancji o różnym rozmiarze, wszystkie ze znanym optymalnym rozwiązaniem. Wybór instancji ze znanym rozwiązaniem podyktowany był tym, że znajomość optimum pozwala na lepszą analizę otrzymanych rezultatów oraz wybranych ustawień algorytmu.

Pierwszą wybraną instancją jest instancja \textit{Had12}. Jej autorami są S.W. Hadley, F. Rendl i H. Wolkowicz. Nazwa instancji pochodzi od nazwiska pierwszego z autorów i rozmiaru (12). Macierz odległości reprezentuje odległości pomiędzy połączonymi obiektami na Mahattanie, natomiast macierz przepływu jest wygenerowana na podstawie równomiernego rozkładu na przedziale \textit{[1,12]}. Znane jest optymalne rozwiązanie i jego wartość wynosi 1652.

Następnie zostały wybrane cztery instancje: \textit{Lipa20a}, \textit{Lipa50b}, \textit{Lipa80a} i \textit{Lipa90a}. Ich autorami są Y. Li i P.M. Pardalos. Podobnie jak powyżej, nazwy instancji pochodzą od ich rozmiarów i nazwisk autorów. Instancje te nie mają konkretnego przełożenia na rzeczywistość, zostały wygenerowana w generatorze problemów. Optymalne wartość dla tych problemów wynoszą odpowiednio 3683, 1210244, 253195 i 360630.

Szóstą z wybranych instancji jest instancja \textit{Kra32}. Jej autorami są J. Krarup i P.M. Pruzan, a zawarte w niej dane są związane z rzeczywistymi danymi wykorzystanymi podczas projektowania kliniki w Regensburgu w Niemczech. Optymalna wartość wynosi 88700.

Siódma z instancji nazwy się \textit{esc64a} i jej autorami są B. Eschermann i H.J. Wunderlich. dane się w niej znajdujące pochodzą z aplikacji testującej pewne sekwencyjne układów samotestujących. Optymalna wartość dla tego problemu wynosi 116.

Następnie została wybrana grupa trzech instancji \textit{chr15b}, \textit{chr18b} i \textit{chr25a} autorstwa N. Christofidesa i E. Benaventa. Optymalne wartości dla tych problemów wynoszą odpowiednio 7990, 1534 i 3796.

Ostatnia, jedenasta instancja testowa nosi nazwę \textit{bur26a} i jej autorami są R.E. Burkard i J. Offermann. Wartości w pierwszej macierzy związane są ze średnim czasem pisania na maszynie stenograficznej, a macierz druga zawiera częstotliwość występowania pewnych par liter w różnych językach. Wartość optymalnego rozwiązania dla tego problemu wynosi 5426670.
 
\section{Scenariusze testowe}
\label{sec:scenariusze}
Z racji tego, iż stosunkowo duża liczba parametrów algorytmu może być zmieniana, nieraz w szerokim zakresie, nie jest możliwe przetestowanie wszystkich możliwych wariantów i porównania uzyskanych dla tych wariantów wyników. Dlatego skupiono się przede wszystkim na badaniu różnic w otrzymywanych rezultatach, gdy zmieniany był tylko jeden parametr. Poprzez wielokrotne uruchamianie algorytmu dla tej samej wygenerowanej populacji początkowej i dla tych samych parametrów uzyskiwane były uśrednione rezultaty. Algorytm z powodu swojej niedeterministycznej natury, zawierającej element losowości, nie pozwala na uzyskanie tych samych rezultatów przy tych samych ustawieniach przy wielokrotnym uruchamianiu. Dlatego więc uśrednianie wyników z wielu prób jest uzasadnione. W skrajnych przypadkach otrzymany wynik może informować o bardzo dobrym działaniu algorytmu, w innym o fatalnym. Algorytmy przybliżone stosowane są przede wszystkim tam, gdzie próby rozwiązania problemu metodami dokładnymi z góry skazane są na niepowodzenie. W przeciwieństwie do eksperymentów, nie jest znane rozwiązanie problemu (gdyby było, jaki byłby cel stosowania tych algorytmów). Poszukiwanie rozwiązania jest wtedy procesem składającym się z wielu prób. Stosowana metodyka testów oddaje więc charakter faktycznych poszukiwań rozwiązania postawionego problemu. Analiza rezultatów eksperymentów pozwala na dobór odpowiednich ustawień parametrów algorytmu, przyczyniających się do efektywnego rozwiązywania problemów podobnych, dla których rozwiązanie nie jest znane. Każdy z opisanych niżej testów polegał na zmianie pewnego jednego testowanego parametru i powtarzany był dla każdej z instancji. Otrzymywane wyniki były porównywane ze sobą, z uwzględnieniem tego, dla której testowej instancji problemu były przeprowadzone. Uśrednione wyniki otrzymywane były na podstawie trzech powtórzeń testu. Z racji tego iż, testowany algorytm w swoich założeniach wykorzystuje bramkę kwantową, poza pierwszą grupą testów, bramka ta zawsze była wykorzystywana, w wersji, która lepiej wypadła w pierwszym eksperymencie.

\subsection{Bramka kwantowa}
Jeszcze w trakcie pisania aplikacji, pojawiło się wiele wątpliwości związanych z operatorem bramki kwantowej. Idea jej stosowania wydaje się być wprawdzie słuszna - odpowiednia modyfikacja osobników w populacji zwiększająca ich prawdopodobieństwo upodobnienia się ich do rozwiązania lepszego od nich i ,,utwierdzenia'' ich w swojej postaci, gdy są lepsze niż porównywane z nimi rozwiązanie gorsze. Jednakże, wykorzystanie jej w praktyce, w postaci proponowanej w publikacji \cite{NPQGA}, często skutkuje otrzymywaniem rezultatów złych. Pojawiła się więc wątpliwość, czy na pewno operator ten jest dobry. Jego stosowanie wydaje się być jednak wymagane - poza mutacją, która teoretycznie zachodzi dość rzadko, operator ten ma możliwość zmiany stanu bitów kwantowych, które są główną cechą algorytmów ewolucyjnych. Bez operatora bramki kwantowej algorytm staje się praktycznie typowym algorytmem genetycznym, w którym jego jedyny związek z kwantowym podejściem do problemu widoczny jest w operatorze mutacji. Z tego powodu została zaproponowana druga wersja bramki rotacyjnej, opisana w rozdziale 5. Seria eksperymentów związanych z wpływem bramki kwantowej na otrzymywane rezultaty miała więc na celu porównania trzech wariantów poszukiwania rozwiązania:
\begin{enumerate}
\item bez wykorzystania bramki kwantowej,
\item z wykorzystaniem bramki kwantowej w wersji proponowanej przez autorów algorytmu NPQGA,
\item z wykorzystaniem bramki kwantowej w wersji proponowanej przez autora niniejszej pracy. 
\end{enumerate}

\subsection{Operator krzyżowania}
Każdy z trzech zaimplementowanych operatorów krzyżowania (CX, OX, PMX) ma inne działanie. W związku z tym krzyżowanie przeprowadzone przy wykorzystaniu jednego z operatorów powinno dać rezultaty inne niż dla innego operatora. Przebieg działania algorytmu genetycznego, uruchomionego dla tych samym parametrów przeważnie wygląda inaczej, nawet jeśli zwracane jest to samo rozwiązanie. W związku z tym, ciężko jest wprost porównać, który z operatorów krzyżowania działa lepiej lub gorzej. Jednakże w przypadku wielokrotnego powtórzenia tego samego testu z wykorzystaniem jednego operatora krzyżowania i uśrednienia wyników, może pozwolić na dostrzeżenie pewnych różnic pomiędzy rezultatami analogicznych testów z wykorzystaniem innego operatora. Z tego powodu testy dotyczące porównania działania operatorów krzyżowania polegały na wielokrotnym uruchamianiu algorytmu dla tych samych parametrów, populacji początkowej i z różnymi wybranymi operatorami krzyżowania.

\subsection{Prawdopodobieństwo krzyżowania}
Algorytm zaimplementowany w aplikacji pozwala na ustawienie minimalnego i maksymalnego prawdopodobieństwa krzyżowania. Ustawienie obu parametrów na tę samą wartość powoduje, że prawdopodobieństwo krzyżowania ma stałą wartość podczas całego działania algorytmu. Należało więc sprawdzić jaki wpływ na otrzymywane rezultaty mają różne wartości stałego prawdopodobieństwa, a także czy zmieniająca się jego wartość w trakcie działania algorytmu powoduje istotne zmiany w efektywności poszukiwania optimum. Testy polegały więc, na porównaniu rezultatów otrzymanych dla małej, średniej i dużej wartości prawdopodobieństwa, a także na porównaniu wyników otrzymanych przy stałym i zmieniającym się prawdopodobieństwie krzyżowania. Przyjęto, że stała wartość prawdopodobieństwa jest średnią arytmetyczną wartości minimalnej i maksymalnej prawdopodobieństwa w teście ze zmiennym prawdopodobieństwem.

\subsection{Prawdopodobieństwo mutacji}
Przyjęło się mówić, że operator mutacji ma drugorzędne znaczenie w kwestii poszukiwania rozwiązań w algorytmie genetycznym. Jednakże natura tego operatora w kontekście zaimplementowanej wersji algorytmu może powodować znaczące zmiany w postaci mutowanego rozwiązania. Eksperymenty badające wpływ prawdopodobieństwa mutacji na otrzymywane rezultaty polegały na testowaniu trzech sytuacji:
\begin{enumerate}
\item prawdopodobieństwo mutacji równe 0,
\item wartość prawdopodobieństwa mała (w stosunku do prawdopodobieństwa krzyżowania),
\item wartość prawdopodobieństwa duża (rząd wielkości prawdopodobieństwa krzyżowania).
\end{enumerate}

\subsection{Operator selekcji}
Każda z dwóch zaimplementowanych metod selekcji ma swoje dobre i złe strony. Należało jednak sprawdzić, która z metod bardziej przydatna jest w przypadku postawionego problemu. Dodatkowo metoda rankingowa pozwala na ustawienie parametru $\eta$, dodatkowo więc należało sprawdzić wpływ tego parametru na uzyskiwane wyniki. Przeprowadzona została więc seria testów porównujących działania obu operatorów oraz seria eksperymentów porównujących działanie operatora selekcji rankingowej z różnymi wartościami parametru $\eta$: wartością minimalną, maksymalną i pośrednią. 

\subsection{Najlepsze parametry}
Ostatni ze scenariuszy testowych jest niejako podsumowaniem scenariuszy wcześniejszych. Polegał on na poszukiwaniu rozwiązania problemu dla parametrów ustawionych na wartości, które na podstawie poprzednich testów uznane zostały za najlepsze (spośród wartości testowanych) i porównaniu otrzymanych wyników z wynikami uzyskanymi w testach opisanych wcześniej. Test ten pozwala na sprawdzenie, czy najlepsze znalezione w testach poprzednich wartości parametrów algorytmu ustawione razem również pozwalają na uzyskiwanie dobrych rozwiązań.

Rozdział ósmy poświęcony jest rezultatom uzyskanym w opisanych wyżej testach, a rozdział dziewiąty analizom uzyskanych w przeprowadzonych eksperymentach rezultatom. 