\chapter{Podsumowanie i wnioski}
\label{cha:wnioski}
Celem niniejszej pracy było dokonanie przeglądu algorytmów przybliżonych w kontekście problemu przydziału kwadratowego oraz prezentacja rezultatów eksperymentów przeprowadzonych przy pomocy napisanej aplikacji komputerowej wykorzystującej wybrany algorytm aproksymacyjny. Dla każdego z zaprezentowanych algorytmów został również przedstawiony możliwy sposób jego wykorzystania w celu rozwiązania problemu QAP. Sposoby te nieraz wymagały specyficznego podejścia do problemu QAP i stosowania ciekawych technik przekształcających problem wyjściowy na taki, który możliwy będzie do rozwiązania przy wykorzystania danego algorytmu. Częste trudności ze znalezieniem prostych sposobów wykorzystania niektórych algorytmów przybliżonych, by rozwiązać problem QAP czy też inny problem, którego rozwiązaniami są permutacje, pokazują, że szeroka gama dostępnych algorytmów przybliżonych jest potrzebna. Nie każdy znany algorytm nadaje się dobrze do rozwiązywania każdego możliwego problemu. Algorytmy mrówkowy i PSO nadają się dobrze do problemów binarnych lub całkowitoliczbowych, w których rozwiązanie nie jest permutacją. Natomiast z tymi rozwiązaniami, które są permutacją, dobrze i w prosty sposób radzą sobie algorytmy genetyczne i tabu search, choć kodowanie rozwiązań w opisywanym algorytmie NPQGA nie jest łatwe.

Ciekawym wnioskiem związanym z algorytmami aproksymacyjnymi jest to, że w dużej mierze swoje pochodzenie zawdzięczają one licznym obserwacjom otaczającego nas świata i próbom wykorzystania mechanizmów działających wokół nas w celu rozwiązywania wielu problemów. Należy tutaj podkreślić kunszt ich twórców, którzy niejednokrotnie po latach badań potrafili wykorzystać swoje obserwacje i stworzyć liczne algorytmy wzorując się na naturze.

Zapoznanie się ze sposobami działania wspomnianych algorytmów pozwoliło stwierdzić, że są one niezwykle przydatnym narzędziem rozwiązywania zagadnień, dla których algorytmy dokładne nie miałby możliwości osiągnięcia sukcesu. Jednakże brak znajomości rozwiązania optymalnego rozwiązywanego problemu nie pozwala na jednoznaczną ocenę poprawności rezultatów, które algorytmy przybliżone pozwalają uzyskać. Weryfikacja poprawności znalezionych rozwiązań wiązać się musi z wielokrotnym powtarzaniem eksperymentów i prowadzeniem często żmudnych analiz statystycznych. 

Proces tworzenia aplikacji oraz przeprowadzone dzięki niej eksperymenty pozwoliły na dogłębne zapoznanie się z ideą algorytmów genetycznych i ich modyfikacji. Natura działania algorytmów genetycznych nadaje się dobrze do wprowadzania różnorakich zmian i ulepszeń, czego ciekawym przykładem jest wykorzystany w programie algorytm NPQGA, który już będąc wariacją na temat algorytmów genetycznych również uległ licznym modyfikacjom. Zastosowanie bitów kwantowych do reprezentacji rozwiązań problemu pozwoliło na uzyskiwanie wielu nieraz zaskakujących rezultatów. Obserwacja stanów kubitów może powodować, że dwa identyczne ciągi bitów kwantowych mogą reprezentować zupełnie inne rozwiązanie problemu. Na uniknięcie całkowitej losowości otrzymywanych rozwiązań ma wpływ nietypowy operator genetyczny, jakim jest bramka kwantowa. ,,Nakierowuje'' ona rozwiązania na rozwiązania lepsze od nich, zwiększając prawdopodobieństwo, że  ich kubity znajda się w stanie takim samym, jak analogiczne kubity rozwiązania lepszego.

Być może przykład algorytmu NPQGA jest jednym z lepszych obrazujących wpływ losowości (pseudolosowości) na uzyskiwanie rozwiązań w algorytmach przybliżonych. Natura działania wielu algorytmów aproksymacyjnych wymaga stosowania liczb losowych (pseudolosowych), co wiąże się ze stosowaniem różnorakich metod generowania takich liczb. Dlatego ważnym elementem są generatory liczb pseudolosowych - zbyt częste generowanie może doprowadzić do uzyskiwania gorszych wyników. Również element losowości powoduje, że algorytmy przybliżone w większości przypadków nie dadzą tych samych rezultatów dla tych samych ustawień początkowych. Korzystanie z tych algorytmów wiąże się więc z wielokrotnym powtarzaniem eksperymentów w celu zapewnienia większej poprawności uzyskiwanych rozwiązań. Dlatego przeprowadzane w ramach celów pracy eksperymenty polegały na wielokrotnym uruchamianiu algorytmu dla tej samej populacji startowej i tych samych jego parametrów oraz analizowaniu wyników uzyskanych na podstawie wielu testów.

Uzyskane rezultaty eksperymentów pozwoliły stwierdzić, że aplikacja została napisana w sposób poprawny, algorytm działa zgodnie z przewidywaniami, a uzyskiwane różnice w stosunku do znanych rozwiązań optymalnych nie są w większości sytuacji duże. Jednak dla pewnych instancji testowych różnice były spore. Podyktowane to mogło być wprowadzonymi do algorytmu modyfikacjom oraz faktem, że algorytm pierwotnie dedykowany był zagadnieniu szeregowania zadań. Nie bez wpływu również mogło być to, że wiele elementów dotyczących implementacji algorytmu nie zostało doprecyzowanych przez samych jego autorów, czego rezultatem było zastosowanie rozwiązań, które mogły faktycznie odbiegać od zamierzeń twórców algorytmu. 